- [주소체계](#%EC%A3%BC%EC%86%8C%EC%B2%B4%EA%B3%84)
	- [IPv4](#IPv4)
	- [IPv6](#IPv6)
		- [차이점](#%EC%B0%A8%EC%9D%B4%EC%A0%90)
	- [어느 게 더 빠를까?](#%EC%96%B4%EB%8A%90%20%EA%B2%8C%20%EB%8D%94%20%EB%B9%A0%EB%A5%BC%EA%B9%8C?)
- [클래스풀](#%ED%81%B4%EB%9E%98%EC%8A%A4%ED%92%80)
	- [개요](#%EA%B0%9C%EC%9A%94)
	- [정의](#%EC%A0%95%EC%9D%98)
	- [단점](#%EB%8B%A8%EC%A0%90)

## 주소체계
### IPv4
32비트 주소체계 - 8비트 단위(옥텟)로 4개로 구분  
ex) 172.16.254.1

### IPv6
128비트와 16진수로 표현되며 16비트씩 8개로 구분되고 연속되는 0은 생략 가능
ex) 2001:0D88:AC10:FE01(:0000:0000:0000:0000)

#### 차이점
1. IPSec 내장
   - 데이터 패킷을 암호화하는 보안 네트워크 프로토콜 제품군이 IPv6에 내장
   - IPv4엔 없음
2. 헤더 포맷
   - IPv4는 각종 옵션 필드로 크기가 가변적
   - IPv6는 불필요한 필드 제거로 고정 길이
3. 체크섬 유무
   - IPv6는 체크섬 필드 X: 상위 프로토콜(TCP, UDP)에 체크섬 필드가 있기 때문에
   - IPv4는 체크섬 필드 존재
4. TTL 용어 변경
   - IPv6에선 TTL[^1]이 HOP limit으로 변경
### 어느 게 더 빠를까?
IPv6는 IPv4보다 헤더가 짧아서 속도가 빠르고 IPSec이 포함되어 보안도 더 좋음.  
하지만 더 느릴 때도 있음.  

---
## 클래스풀
### 개요
IP 주소는 네트워크 주소와 호스트 주소로 나뉨  

### 정의
![[클래스풀.jpg]]
네트워크 주소를 매기고 그에 따라 네트워크의 크기를 다르게 구분하여 클래스를 할당하는 주소 체계  
호스트 주소는 맨 앞자리는 네트워크 주소, 가장 마지막 주소는 브로드캐스팅 주소이기 때문에 2의 제곱에서 2를 뺀다.  

1. 클래스 A
   - 0xxxxxxx + 24비트 호스트 주소: 2^24 - 2개
   - 네트워크 주소: 1~126으로 시작 / 127.x는 루프백 주소라서 제외 / 0.0.0.0도 특수 주소라서 제외
2. 클래스 B
   - 10xxxxxxxxxxxxxx + 16비트 호스트 주소: 2^16 - 2개
   - 네트워크 주소: 128~191
3. 클래스 C
   - 110x(21비트) + 8비트 호스트 주소: 2^8 - 2개
   - 네트워크 주소: 192~223
### 단점
IP 주소를 할당하는데 굉장히 비효율적일 수 있다. 호스트의 개수에 비해 하위 클래스는 개수가 적고 상위 클래스는 개수가 너무 많다.  

---
## 클래스리스
### 개요
위와 같은 클래스풀의 단점을 해결하고자 클래스가 아니라 서브넷마스크로 네트워크 주소와 호스트 주소를 나누는 방법  
ex) 192.168.0.1/24  

### 서브넷마스크
/ 뒤의 숫자가 서브넷마스크를 의미한다. /24라면 처음부터 24개까지 1로 구성된다.  
즉, 32-24=12자리가 호스트 주소용이다.  

### 예시
**Q. 사무실당 12개의 호스트를 연결하여 총 10개의 사무실이 있다면?**  
A. 사무실 하나당 호스트 주소로 4비트를 사용(2^4 - 2 = 16 - 2 = 14). 즉, 32 - 4 = 28이 네트워크 주소 비트 수. ex) 123.12.12.12/28  

---
## 공인 IP와 사설 IP
IPv4가 이미 포화됐으므로 알뜰살뜰하게 써야 한다. 이러한 IP 주소 부족을 공인 IP(Public IP)와 사설 IP(Private IP)로 나누고 NAT로 번역하여 해결한다.  

### NAT
NAT(Network Address Translation)은 패킷이 


[^1]: Time To Live. 패킷이 네트워크에서 무한 순환하지 않도록 수명을 정해놓음. 라우터를 하나 지날 때마다 1씩 감소.
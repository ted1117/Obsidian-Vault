## URL 쿼리
유감스럽게도 API로 받는 데이터에서 해당 도서가 만화임을 바로 알 수 없다. 그래서 내가 생각한 방법은 3단계로 구성된다.
* 출판사
* ISBN 부가 기호
* 주제
### 출판사
주로 내가 보는 만화는 만화출판사에서 발간되는 경우가 많다. ex) 대원씨아이, 학산문화사 etc...
하지만 문제가 있다. 만화출판사도 꼭 일본 만화만 출판하진 않는다. 더군다나 문학동네 같이 대형 출판사도 만화를 출간하기 때문에 출판사로만 만화임을 걸러내기 쉽지 않다. 그래도 일단 url 쿼리는 출판사를 기준으로 한다. 요청할 땐 정말로 다른 방법이 없다.
### ISBN 부가 기호
요청을 해서 받은 데이터에 EA_ADD_CODE가 있다.  ISBN은 주로 13자리로 구성되는데 마지막 5자리가 부가 기호이다.
* 제1행: 독자대상기호

| 기호  |   대상독자   | 설명                            |
| :-: | :------: | ----------------------------- |
|  0  |    교양    | 일반 독자 대상. 주로 전문 내용을 풀어쓴 교양 도서 |
|  1  |    실용    | 실무과 관련된 내용                    |
|  4  |   청소년    | 참고서를 제외한 청소년 대상 도서            |
|  5  | 중·고교 참고서 | 제곧내                           |
|  6  |  초교 참고서  | 제곧내                           |
|  7  |    아동    | 초등 참고서를 제외한 영유아 및 초등학생 대상 도서  |
|  9  |    전문    | 학술·전문 도서                      |
* 제2행: 발행형태기호

| 기호  | 형태                 | 설명             |
| --- | ------------------ | -------------- |
| 0   | 문고본                | 세로 15cm 이하 자료  |
| 1   | 사전                 | 사전             |
| 2   | 신서판                | 세로 18cm 미만 자료  |
| 3   | 단행본                | 세로 18cm 이상 자료  |
| 4   | 전집·총서·시리즈          | 전집             |
| 5   | 전자출판물              | 전자책, CD, DVD 등 |
| 6   | 도감                 | 도감류            |
| 7   | 그림책, 만화            | 초등그림책, 만화      |
| 8   | 혼합자료, 점자자료, 마이크로자료 | 제곧내            |
* 제3-5행: 내용분류기호

| 기호  |      내용      | 간략분류 |      |      |                |     |            |
| :-: | :----------: | :--: | ---- | ---- | -------------- | --- | ---------- |
|  0  |      총류      |      |      |      |                |     |            |
|  1  | 철학, 심리학, 윤리학 |      |      |      |                |     |            |
|  2  |      종교      |      |      |      |                |     |            |
|  3  |     사회과학     |      |      |      |                |     |            |
|  4  |     자연과학     |      |      |      |                |     |            |
|  5  |     기술과학     |      |      |      |                |     |            |
|  6  |      예술      |      |      |      |                |     | 회화, 도화, 판화 |
|  7  |      언어      |      |      |      |                |     |            |
|  8  |      문학      | 문학일반 | 한국문학 | 중국문학 | 일본 및 기타 아시아 문학 |     |            |
|  9  |  역사, 지리, 관광  |      |      |      |                |     |            |

다른 분류는 필요 없다. 필요한 것만 보자.
대부분의 출판사는 05830이라고 한다. 교양(?)-전자책-문학(?)-일본문학이라서 05830.
그런데 이걸 따르지 않는 출판사들이 있다.
학산문화사는 만화를 문학으로 보지 않고 예술로 본다. 역시 식질을 열심히 하는 회사는 다르다.
그래서 학산문화사는 05650이다. 교양-전자책-예술-판화. 예술이다.
서울미디어코믹스는 한술 더 뜬다. 독자의 연령대에 따라 성인만화면 05830, 아니라면 45830.
굉장히 철저하다. 덕분에 내 머릿속은 혼란으로 가득찼지만.
하여튼 이 때문에 나는 쿼리할 때 출판사 리스트를 만들었지만 그냥 모델을 하나 만들기로 결정했다.
```python
class Publisher(models.Model):
	name = models.CharField(max_length=50)
	ea_add_code = models.CharField(max_length=6, default="05830")
	subject = models.IntegerField(default=8)
	search_keyword = models.CharField(max_length=50, blank=True)
	
	def __str__(self) -> str:
		return self.name
	
	def save(self, *args, **kwargs):
		if not self.search_keyword:
			self.search_keyword = self.name
			super().save(*args, **kwargs)
```
subject는 이제 생각해보니까 필요가 없다. ISBN 부가기호 세 번째 자리와 동일하다. 하여튼 대부분의 출판사는 05830으로 지정하기 때문에 기본값으로 설정했다. 
search_keyword는 url 쿼리에 쓰일 출판사 이름이다. 대부분 회사 이름(name)을 그대로 쓰면 되지만 대외적인 회사 이름과 전산에 등록되는 이름이 다른 경우가 종종 있다. 예를 들어 AK 커뮤니케이션즈는 '(도서출판)에이케이', YNK미디어는 '와이앤케이미디어', DCW는 '디씨더블유'라고 한다. 이제 보니 모두 회사 이름에 영어가 들어간다. 하지만 그중에서도 제일 갑은 블루픽. 이놈들은 회사 이름이 길찾기, 이미지프레임, 블루픽 순으로 바뀌었으면서 최근까지도 전산에 등록할 때 자기들 회사 이름을 가지각색으로 등록한다. 그나마 전자책은 이미지프레임으로 등록하는 모양이다. 하나만 하면 좋겠다. 대부분은 이름을 그대로 쓰면 되기 때문에 따로 search_keyword를 지정하지 않으면 이름과 동일하게 저장되도록 save 메소드를 오버라이딩 했다.

---
## 역직렬화 문제
### API 방식
일단 모델을 쓰기로 한 이상, API에서 데이터를 받아 역직렬화를 해서 DB에 저장한 다음, 클라이언트에 정제한 데이터를 제공해야 한다.
### 1단계
먼저 API에서 데이터를 받으려면 당연히 쿼리를 해야 한다. 쿼리는 [[#URL 쿼리]] 문단에서 보다시피 출판사 이름을 기준으로 데이터를 불러온다. 근데 전자책은 만화만 받을 수 있는 방법이 없기 때문에 출판사 수만큼 쿼리를 한다. 2024년 4월에 출간될 일본 만화는 440개로 추산된다.[^1] 그래서 어쩔 수 없이 반복문을 사용했다. 덕분에 데이터는 잘 불러올 수 있었다.
### 2단계
데이터를 불러왔으면 데이터를 정제해야 한다. 받은 데이터엔 값이 공백인 쓸모없는 key가 많기 때문에 필요한 key, value만 뽑는다. 그리고 난 연재물은 관심이 없기 때문에 연재도 제외한다. 연재물은 PRE_PRICE에 "연재가"라고 저장되어 있다. 그래서 PRE_PRICE의 값이 숫자, 정확히는 문자가 아님을 알기 위해 isalpha()메소드를 사용하였고, 각 출판사 별 만화에 할당하는 ISBN 부가 기호를 확인하여 데이터를 정제했다.
```python
selected_data += [
	{
		"title": manga["TITLE"],
		"series_title": manga["SERIES_TITLE"],
		"author": manga["AUTHOR"],
		"publisher": publisher.pk,
		"published_at": datetime.strptime(manga["PUBLISH_PREDATE"], "%Y%m%d").date(),
		"price": int(manga["PRE_PRICE"]),
		}
		for manga in data["docs"]
		if not manga["PRE_PRICE"].isalpha() and manga["EA_ADD_CODE"] == publisher.ea_add_code
]
```
published_at의 필드는 DateField이므로 시간 형으로 변환하고, 가격은 int형으로 변환한다.

### 역직렬화
기본적인 역직렬화 과정은 다음과 같다.
```python
serializer = XXXSerializer(data=data)
serializer.is_valid(raise_exception=True)
serializer.save()
```
데이터를 Serializer에 넣어 역직렬화를 한 다음 유효성 검사를 거쳐 DB에 저장한다.
근데 이건 데이터가 하나일 때 이야기이고 나는 받아오는 데이터가 수백 개이기 때문에 동시에 처리해야 한다. 따라서 Serializer에 many=True를 붙였다.
여기까지 문제가 없어야 할텐데 안타깝게도 나는 Publisher가 JSON으로 직렬화할 수 없다는 오류를 맞닥뜨렸다. 여기엔 내가 두 가지 실수를 했는데...
1. publisher에 내가 Publisher 객체를 넣었다.
2. 클라이언트에 전송할 때 데이터를 다시 직렬화해야 하는 걸 깜빡했다.
1번은 모델에 아래와 같이 해결할 수 있다.
```python
# serializers.py
class MangaModelSerializer(serializers.ModelSeralizer):
	publisher = serializers.StringRelatedField()
	...
```
StringRelatedField는 해당 모델을 정의할 때  \__str\__ 메소드를 정의한 대로 출력한다.

2번은 당연하게도 직렬화를 하면 된다.

[^1]: 사실 더 많다. 소미미디어는 정확한 출간일을 기입하지 않고 이미지프레임은 그냥 등록 자체를 누락했다.
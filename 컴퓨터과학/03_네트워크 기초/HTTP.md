- [HTTP/1.0](#HTTP/1.0)
- [HTTP/1.1](#HTTP/1.1)
	- [keep-alive default](#keep-alive%20default)
	- [호스트 헤더](#%ED%98%B8%EC%8A%A4%ED%8A%B8%20%ED%97%A4%EB%8D%94)
	- [대역폭 최적화](#%EB%8C%80%EC%97%AD%ED%8F%AD%20%EC%B5%9C%EC%A0%81%ED%99%94)
	- [단점](#%EB%8B%A8%EC%A0%90)
- [요청 줄이기](#%EC%9A%94%EC%B2%AD%20%EC%A4%84%EC%9D%B4%EA%B8%B0)
	- [이미지 스프라이트](#%EC%9D%B4%EB%AF%B8%EC%A7%80%20%EC%8A%A4%ED%94%84%EB%9D%BC%EC%9D%B4%ED%8A%B8)
	- [코드 압축](#%EC%BD%94%EB%93%9C%20%EC%95%95%EC%B6%95)
	- [이미지 Base64 인코딩](#%EC%9D%B4%EB%AF%B8%EC%A7%80%20Base64%20%EC%9D%B8%EC%BD%94%EB%94%A9)
- [HTTP/2](#HTTP/2)
	- [바이너리 포맷 계층](#%EB%B0%94%EC%9D%B4%EB%84%88%EB%A6%AC%20%ED%8F%AC%EB%A7%B7%20%EA%B3%84%EC%B8%B5)
	- [멀티플렉싱](#%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%89%EC%8B%B1)
	- [서버푸시](#%EC%84%9C%EB%B2%84%ED%91%B8%EC%8B%9C)
	- [헤더 압축](#%ED%97%A4%EB%8D%94%20%EC%95%95%EC%B6%95)
	- [우선순위](#%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84)
- [HTTP/3](#HTTP/3)
- [개요](#%EA%B0%9C%EC%9A%94)
- [스크램블](#%EC%8A%A4%ED%81%AC%EB%9E%A8%EB%B8%94)
- [암호화](#%EC%95%94%ED%98%B8%ED%99%94)
	- [대칭 암호화](#%EB%8C%80%EC%B9%AD%20%EC%95%94%ED%98%B8%ED%99%94)
	- [비대칭 암호화](#%EB%B9%84%EB%8C%80%EC%B9%AD%20%EC%95%94%ED%98%B8%ED%99%94)
	- [필요성](#%ED%95%84%EC%9A%94%EC%84%B1)
- [단계](#%EB%8B%A8%EA%B3%84)
- [Diffie-Hellman](#Diffie-Hellman)
- [사이퍼슈트](#%EC%82%AC%EC%9D%B4%ED%8D%BC%EC%8A%88%ED%8A%B8)
	- [AEAD 사이퍼 모드](#AEAD%20%EC%82%AC%EC%9D%B4%ED%8D%BC%20%EB%AA%A8%EB%93%9C)
	- [해싱 알고리즘](#%ED%95%B4%EC%8B%B1%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
	- [CA](#CA)
	- [인증서](#%EC%9D%B8%EC%A6%9D%EC%84%9C)
	- [RSA의 취약점](#RSA%EC%9D%98%20%EC%B7%A8%EC%95%BD%EC%A0%90)
	- [0-RTT](#0-RTT)

# HTTP/1.0과 HTTP/1.1의 차이
## HTTP/1.0
매 연결마다 [[TCP·IP 4계층#TCP 연결|3-way handshake]]를 수행하여 RTT가 늘어나는 단점이 있다.  

## HTTP/1.1
기존 1.0을 세 가지 측면에서 보완한 프로토콜  

### keep-alive default
![[keep-alive.png]]  
1.0과 달리 TCP 연결이 구축된 이후에 연결이 끊길 때까지 계속 데이터를 주고 받을 수 있다.  
1.0엔 시험적으로 있었고 1.1때 기본값이 되었다.  
### 호스트 헤더
1.0은 서버에 호스트가 단 하나라고 가정했기 때문에 헤더에 호스트가 포함되지 않았다.  
1.1은 서버에 여러 개의 호스트가 있는 것을 염두하고 헤더에 호스트 정보를 포함한다.  

### 대역폭 최적화
1.1부터는 파일 다운로드가 중간에 끊겨도 재개할 수 있다.  

### 단점
![[HOL Blocking.png]]  
HOL Blocking(Head Of Line blocking): 패킷은 클라이언트가 요청한 순서대로 서버가 클라이언트에 전송하는데 앞 패킷이 크기가 커서 속도가 느려지면 뒤의 패킷들도 줄줄이 지연된다.

## 요청 줄이기
1.1이 되어도 요청할 때마다 RTT가 증가하기 때문에 요청 자체를 줄이는 기술이 나왔다.  

### 이미지 스프라이트
![[image-sprite.png]]  
웹 페이지에 필요한 수많은 이미지를 하나의 이미지로 합친다.  

### 코드 압축
코드에 포함된 공백문자, 띄어쓰기, 개행을 줄인다.

### 이미지 Base64 인코딩
이미지 파일을 64진법 문자열로 인코딩하여 이미지 서버에 요청할 필요가 없도록 만든다.  
하지만 파일 크기가 대략 37% 증가한다.  

---
# HTTP/2와 HTTP/3
## HTTP/2
### 바이너리 포맷 계층
![[바이너리 포맷 계층.png]]  
또는 바이너리 프레이밍 계층이라고도 한다. 애플리케이션 계층과 전송 계층 사이에 바이너리 포맷 계층을 추가하여 기존 HTTP/1.x에선 HTTP 메시지가 개행으로 구분되는 일반 텍스트였으나 바이너리 포맷 계층에서 더 작은 메시지와 프레임으로 분활되어 바이너리 형식(0과 1)으로 인코딩된다.  

### 멀티플렉싱
단일 TCP 연결의 여러 스트림에서 여러 HTTP 요청과 응답을 비동기적으로 전송하여 HOL Blocking을 해결한다.[^1]  

> [!NOTE]  
> **스트림** HTTP/2.0에서 클라이언트와 서버 사이에 교환되는 프레임의 독립된 양방향 시퀀스  
> **메시지** 논리적 요청이나 응답에 매핑되는 프레임의 전체 시퀀스
> **프레임** HTTP/2.0에서 통신의 최소 단위이며 하나의 프레임 헤더 포함되어 스트림 식별

프레임에 포함된 스트림 ID로 프레임이 분할되더라도 응답 데이터에서 올바른 순서대로 재조립  

### 서버푸시
클라이언트의 요청 없이 서버가 클라이언트에 리소스를 푸시  
ex) 요청한 HTML에 CSS가 포함되었다면 CSS를 따로 요청하지 않아도 서버가 CSS를 전송  

### 헤더 압축
헤더를 허프만 인코딩으로 압축한다.  
> [!note] 
> **허프만 인코딩**  
> 문자열에서 문자의 출연 빈도 수에 따라 비트를 부여하는 방식  
> 공통되는 필드를 중심으로 재구성  

### 우선순위
서버에서 원하는 우선순위대로 리소스 전달  

## HTTP/3
HTTP/2는 여전히 TCP를 이용하기 때문에 초기 연결 단계에서 RTT로 인한 지연 시간 발생  
QUIC(Quick UDP Internet Connection) 계층을 이용한다.  

![[QUIC.webp]]  
기존 HTTP/2는 TCP 연결 외에 암호화 통신을 위한 TLS 핸드셰이크를 따로 수행했으나  
HTTP/3는 UDP 기반의 QUIC 덕에 단 한 번의 핸드셰이크로 세션과 TLS 연결을 모두 구축한다.  

또한 전송된 패킷의 손실 여부를 수신측에서 검출하여 수정하는 FEC(Forward Error Correction)이 있다.  

---
# HTTPS와 TLS
## 개요
- 암호화
	- 승인된 당사자만 정보를 이해할 수 있도록 데이터를 **스크램블**한 방법
## 스크램블
각 단어나 문자를 패턴이 아닌 무작위로 개별 데이터 비트를 섞는 것  
비트가 높아질수록 스크램블 회수가 늘어나 더 복잡해짐  

## 암호화
### 대칭 암호화
키를 하나만 사용하는 암호화  

### 비대칭 암호화
- **방법**
	- 공개키로 암호화하고 개인키로 복호화  
	- 개인키로 서명하고 공개키로 검증  
- **종류**
	- RSA
	- DH(Diffie-Hellman)
- **예시**
	- TLS는 부분적으로 비대칭 암호화 사용
	- 비대칭 암호화로 인증 후, 세션키 기반으로 대칭 암호화로 통신

### 필요성
송수신자 외의 다른 인물이 통신을 가로채지 않도록 하여 민감한 데이터의 유출을 방지하고 데이터 무결성을 보장  

---
# TLS 핸드셰이크
TLS(Transport Layer Secure)는 SSL(Secure Socket Layer) 1.0, 2.0, 3.0을 거쳐 SSL 3.0을 기반으로 개발된 전송 계층 암호화 프로토콜이다.  

## 단계
1. **ClientHello**
   클라이언트가 서버에 지원하는 TLS 버전, 사이퍼슈트, 클라이언트 랜덤값, 임시 DH 매개변수를 서버에 전송  
2. **ServerHello / EncryptedExtensions / Certificate / CertificateVerify**
   - 서버가 서버와 클라이언트에서 모두 지원하는 가장 높은 TLS 버전 결정
   - 서버 랜덤값, TLS 버전, 사이퍼 슈트를 포함한 메시지 전송
3. **ServerKeyExchange**(선택적)
   - 서버가 DH 정보를 클라이언트에 전송(RSA가 아닐 때 한정)
4. **CertificateRequest**(선택적)
   - 서버가 클라이언트에 인증서 요청
5. **ServerHelloDone**
   - 서버가 초기 설정을 완료했음을 클라이언트에 고지
6. **ClientKeyExchange**
   - 클라이언트가 서버의 DH 매개변수로 Pre-Master Secret을 생성하고 서버에 전송
   - 이를 바탕으로 클라이언트와 서버가 세션키 생성
7. **CertificateVerify**(선택적)
   - 클라이언트가 서버에 인증서 전송
8. **ChangeCipherSpec**
   - 서버가 선택한 암호화 알고리즘을 적용
   - 클라이언트가 암호화 통신 준비 완료를 서버에 전송
9. **Finished**
   - 대칭 암호화 통신 개시

## Diffie-Hellman
![[1920px-Diffie-Hellman_Key_Exchange.svg_png 1.jpg]]  
공개값을 공유하고 비밀값을 혼합한 뒤 공유하고 비밀값을 혼합하여 공통 암호키를 생성하는 알고리즘  

## 사이퍼슈트
프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 규약을 말하며, 암호제품군이라고도 함.  
TLS 1.3엔 5개가 있음
- TLS_AES_128_GCM_SHA256
TLS / AES 128 GCM / SHA256 세 가지 규약을 포함한다는 뜻  
- TLS: 프로토콜  
- AES_128_GCM: AEAD 사이퍼 모드
- SHA256: 해싱 알고리즘

### AEAD 사이퍼 모드
AEAD(Authenticated Encryption with Associated Data)는 데이터 암호화 알고리즘

### 해싱 알고리즘
데이터를 추정하기 힘들게 더 작고 섞여 있는 조각으로 만드는 알고리즘  

### CA
CA(Certificate Authority)는 인증서를 발급하는 기관이다.

### 인증서
인증서를 발급한 CA, 도메인, 웹사이트 소유자, 인증서 소유자(주체)와 공개키를 포함한 데이터 파일  
보통 인증기관 CA에서 발급하는 SSL 인증서를 기반으로 인증 작업 수행  
주체는 클라이언트가 접속한 서버가 적합한 서버가 맞는지 확인할 때 쓰이고, 공개키는 처음 인증 작업을 수행할 때 쓰임.  

- **단일 도메인**
  단 하나의 도메인에 적용되는 인증서
- **와일드 카드**
  메인 도메인의 하위 도메인도 포함하는 인증서
- **멀티 도메인**
  관련성 없는 여러 도메인에 적용되는 인증서

### RSA의 취약점
DH는 클라이언트와 서버가 서로 교환한 DH 매개변수로 개인키를 생성하나 RSA는 클라이언트가 단독으로 생성한 임시 암호값을 서버에 전송하므로 탈취될 경우 해킹의 위험이 있다.  

### 0-RTT
세션키가 생성된 이후, 사이트를 다시 방문하면 세션키(PSK, Pre-Shared Key)를 기반으로 연결이 생성되므로 인증 관련 RTT가 발생하지 않는다.  


[^1]: 기존 HTTP/1.x에선 단일 TCP 연결로 병렬 요청이 불가했다.
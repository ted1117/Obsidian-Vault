목차
# HTTP/1.0과 HTTP/1.1의 차이
## HTTP/1.0
매 연결마다 [[TCP·IP 4계층#TCP 연결|3-way handshake]]를 수행하여 RTT가 늘어나는 단점이 있다.  

## HTTP/1.1
기존 1.0을 세 가지 측면에서 보완한 프로토콜  

### keep-alive default
![[keep-alive.png]]  
1.0과 달리 TCP 연결이 구축된 이후에 연결이 끊길 때까지 계속 데이터를 주고 받을 수 있다.  
1.0엔 시험적으로 있었고 1.1때 기본값이 되었다.  
### 호스트 헤더
1.0은 서버에 호스트가 단 하나라고 가정했기 때문에 헤더에 호스트가 포함되지 않았다.  
1.1은 서버에 여러 개의 호스트가 있는 것을 염두하고 헤더에 호스트 정보를 포함한다.  

### 대역폭 최적화
1.1부터는 파일 다운로드가 중간에 끊겨도 재개할 수 있다.  

### 단점
![[HOL Blocking.png]]  
HOL Blocking(Head Of Line blocking): 패킷은 클라이언트가 요청한 순서대로 서버가 클라이언트에 전송하는데 앞 패킷이 크기가 커서 속도가 느려지면 뒤의 패킷들도 줄줄이 지연된다.

## 요청 줄이기
1.1이 되어도 요청할 때마다 RTT가 증가하기 때문에 요청 자체를 줄이는 기술이 나왔다.  

### 이미지 스프라이트
![[image-sprite.png]]  
웹 페이지에 필요한 수많은 이미지를 하나의 이미지로 합친다.  

### 코드 압축
코드에 포함된 공백문자, 띄어쓰기, 개행을 줄인다.

### 이미지 Base64 인코딩
이미지 파일을 64진법 문자열로 인코딩하여 이미지 서버에 요청할 필요가 없도록 만든다.  
하지만 파일 크기가 대략 37% 증가한다.  

---
# HTTP/2와 HTTP/3
## HTTP/2
### 바이너리 포맷 계층
![[바이너리 포맷 계층.png]]  
또는 바이너리 프레이밍 계층이라고도 한다. 애플리케이션 계층과 전송 계층 사이에 바이너리 포맷 계층을 추가하여 기존 HTTP/1.x에선 HTTP 메시지가 개행으로 구분되는 일반 텍스트였으나 바이너리 포맷 계층에서 더 작은 메시지와 프레임으로 분활되어 바이너리 형식(0과 1)으로 인코딩된다.  

### 멀티플렉싱
단일 TCP 연결의 여러 스트림에서 여러 HTTP 요청과 응답을 비동기적으로 전송하여 HOL Blocking을 해결한다.[^1]  

> [!NOTE]  
> **스트림** HTTP/2.0에서 클라이언트와 서버 사이에 교환되는 프레임의 독립된 양방향 시퀀스  
> **메시지** 논리적 요청이나 응답에 매핑되는 프레임의 전체 시퀀스
> **프레임** HTTP/2.0에서 통신의 최소 단위이며 하나의 프레임 헤더 포함되어 스트림 식별

프레임에 포함된 스트림 ID로 프레임이 분할되더라도 응답 데이터에서 올바른 순서대로 재조립  

### 서버푸시
클라이언트의 요청 없이 서버가 클라이언트에 리소스를 푸시  
ex) 요청한 HTML에 CSS가 포함되었다면 CSS를 따로 요청하지 않아도 서버가 CSS를 전송  

### 헤더 압축
헤더를 허프만 인코딩으로 압축한다.  
> [!note] 
> **허프만 인코딩**  
> 문자열에서 문자의 출연 빈도 수에 따라 비트를 부여하는 방식  
> 공통되는 필드를 중심으로 재구성  

### 우선순위
서버에서 원하는 우선순위대로 리소스 전달  

## HTTP/3
HTTP/2는 여전히 TCP를 이용하기 때문에 초기 연결 단계에서 RTT로 인한 지연 시간 발생  
QUIC(Quick UDP Internet Connection) 계층을 이용한다.  

![[QUIC.webp]]  
기존 HTTP/2는 TCP 연결 외에 암호화 통신을 위한 TLS 핸드셰이크를 따로 수행했으나  
HTTP/3는 UDP 기반의 QUIC 덕에 단 한 번의 핸드셰이크로 세션과 TLS 연결을 모두 구축한다.  

또한 전송된 패킷의 손실 여부를 수신측에서 검출하여 수정하는 FEC(Forward Error Correction)이 있다.  

---
# HTTPS와 TLS
## 개요
- 암호화
	- 승인된 당사자만 정보를 이해할 수 있도록 데이터를 **스크램블**한 방법
## 스크램블
각 단어나 문자를 패턴이 아닌 무작위로 개별 데이터 비트를 섞는 것  
비트가 높아질수록 스크램블 회수가 늘어나 더 복잡해짐  

## 암호화
### 대칭 암호화
키를 하나만 사용하는 암호화  

### 비대칭 암호화
- **방법**
	- 공개키로 암호화하고 개인키로 복호화  
	- 개인키로 서명하고 공개키로 검증  
- **종류**
	- RSA
	- DH(Diffie-Hellman)
- **예시**
	- TLS는 부분적으로 비대칭 암호화 사용
	- 비대칭 암호화로 인증 후, 세션키 기반으로 대칭 암호화로 통신

### 필요성
송수신자 외의 다른 인물이 통신을 가로채지 않도록 하여 민감한 데이터의 유출을 방지하고 데이터 무결성을 보장  

---
# TLS 핸드셰이크
TLS(Transport Layer Secure)는 SSL(Secure Socket Layer) 1.0, 2.0, 3.0을 거쳐 SSL 3.0을 기반으로 개발된 전송 계층 암호화 프로토콜이다.  

## 단계
1. **ClientHello**
   클라이언트가 서버에 지원하는 TLS 버전, 사이퍼슈트, 클라이언트 랜덤값, 임시 DH 매개변수를 서버에 전송  
2. **ServerHello / EncryptedExtensions / Certificate / CertificateVerify**
   - 서버가 서버와 클라이언트에서 모두 지원하는 가장 높은 TLS 버전 결정
   - 서버 랜덤값, TLS 버전, 사이퍼 슈트를 포함한 메시지 전송
3. **ServerKeyExchange**(선택적)
   - 서버가 DH 정보를 클라이언트에 전송(RSA가 아닐 때 한정)
4. **CertificateRequest**(선택적)
   - 서버가 클라이언트에 인증서 요청
5. **ServerHelloDone**
   - 서버가 초기 설정을 완료했음을 클라이언트에 고지
6. **ClientKeyExchange**
   - 클라이언트가 서버의 DH 매개변수로 Pre-Master Secret을 생성하고 서버에 전송
   - 이를 바탕으로 클라이언트와 서버가 세션키 생성
7. **CertificateVerify**(선택적)
   - 클라이언트가 서버에 인증서 전송
8. **ChangeCipherSpec**
   - 서버가 선택한 암호화 알고리즘을 적용
   - 클라이언트가 암호화 통신 준비 완료를 서버에 전송
9. **Finished**
   - 대칭 암호화 통신 개시

## Diffie-Hellman
![[1920px-Diffie-Hellman_Key_Exchange.svg_png 1.jpg]]  
공개값을 공유하고 비밀값을 혼합한 뒤 공유하고 비밀값을 혼합하여 공통 암호키를 생성하는 알고리즘  

## 사이퍼슈트
프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 규약을 말하며, 암호제품군이라고도 함.  
TLS 1.3엔 5개가 있음
- TLS_AES_128_GCM_SHA256
TLS / AES 128 GCM / SHA256 세 가지 규약을 포함한다는 뜻  
- TLS: 프로토콜  
- AES_128_GCM: AEAD 사이퍼 모드
- SHA256: 해싱 알고리즘

### AEAD 사이퍼 모드
AEAD(Authenticated Encryption with Associated Data)는 데이터 암호화 알고리즘

### 해싱 알고리즘
데이터를 추정하기 힘들게 더 작고 섞여 있는 조각으로 만드는 알고리즘  
[^1]: 기존 HTTP/1.x에선 단일 TCP 연결로 병렬 요청이 불가했다.